第一版O(nlog(n)) time, O(n) Space。

很容易想到的先将nums排序，然后将后半段逐一插入到前半段的两个数之间。

需要注意的是需要将前半段**倒序**，然后将后半段**倒序**插入到前半段之间。

其实是防止前半段的最后一个数和后半段的第一个数相等。

这样就把前半段的最后一个数放到最前，把后半段的第一个数放到最末，保证其不相邻。

submit的结果为:
```
44 / 44 test cases passed.
Status: Accepted
Runtime: 150 ms
```

第二版就把空间复杂度变为O(1) Space，但是时间复杂度还是没变。

因为还是需要排序，其他语言可以用nth_element来实现部分排序。

即需要将比中位数小的放到其左侧，比中位数大的放到其右侧，而不用管这两部分的排序。

据说平均的时间复杂度可以达到O(n)，但先不管这个，此次的关注点不在这。

关注点是如何在原序列上实现第一版的调换顺序。

哈哈。

首先得先讲一个3-way-partition三部分划分法。

问题是这样的，举个例子，”荷兰国旗难题“，荷兰国旗是由红、白、蓝三色组成的。

现在有若干个红、白、蓝三种颜色的球随机排列成一条直线。

任务是把这些球按照红、白、蓝排序。即红的在白的前面，白的在蓝的前面。

由于红、白、蓝三色小球数量并不一定相同，所以这个三个区域不一定是等分的。

思路如下：将前部和后部各排在数组的前边和后边，中部自然就排好了。

```
设置两个标志位begin和end分别指向这个数组的开始和末尾，
然后用一个标志位current从头开始进行遍历：
1）若遍历到的位置为0，则说明它一定属于前部，
   于是就和begin位置进行交换，然后current向前进，
   begin加1（表示前边的已经都排好了）。
2）若遍历到的位置为1，则说明它一定属于中部，
   根据总思路，中部的我们都不动，然后current向前进。
3）若遍历到的位置为2，则说明它一定属于后部，
   于是就和end位置进行交换，由于交换完毕后current指向的可能是属于前部的，
   若此时current前进则会导致该位置不能被交换到前部，
   所以此时current不动，end减1。
```

然后回到我们的问题，我们想要做的是将比中位数小的逆序放到偶数下标中，
而比中位数大的放到奇数下标中。

举个例子。我们希望把上方的下标中的数移动到下方的下标中。

```
0, 1, 2, 3, 4,    5, 6, 7, 8, 9
|  |  |  |  |     |  |  |  |  |
8, 6, 4, 2, 0,    9, 7, 5, 3, 1
```

根据3-way-partition三部分划分法。
如果我们想调换已排序的两侧的数字，
将大于中位数mid的放到前面，而小于mid的放到后面，
则只需按照标准做法：

```
1. 在nums[cur]>mid的时候swap(nums[cur], nums[begin])，然后begin++，cur++。
2. 在nums[cur]<mid的时候swap(nums[cur], nums[end])，然后end--。
3. 在nums[cur]==mid的时候cur++。
```

这样就可以将0换到9，1换到8，2换到7...

```
0, 1, 2, 3, 4            9, 8, 7, 6, 5
                 --->
5, 6, 7, 8, 9            4, 3, 2, 1, 0
```

更进一步地，
如果此时我们对下标而不是值本身做一个映射，称为virtual-index。如下图所示。
右侧为`下标(值)`的形式

```
0, 1, 2, 3, 4            1(9), 3(8), 5(7), 7(6), 9(5)
                 --->
5, 6, 7, 8, 9            0(4), 2(3), 4(2), 6(1), 8(0)
```

我们就可以把比中位数大的5， 6， 7， 8， 9逆序放到1， 3， 5， 7， 9中。
而比中位数小的0， 1， 2， 3， 4逆序放到0， 2， 4， 6， 8中。

所以只是放到的下标的位置发生了变化，而值的比较是没有变的，
依然是大于mid，小于mid，等于mid。

此时就不是nums[begin], nums[cur], nums[end]。而变成了

```
nums[((begin * 2 + 1) % (n|1)],
nums[((cur * 2 + 1) % (n|1)],
nums[((end * 2 + 1) % (n|1)],
```

`n|1`表示偶数就加1，奇数不变。所以关键是能把这个映射用公式表示出来。

乘2然后加1很容易映射为奇数下标，而映射为偶数下标则需求余数(`%(n|1)`)。

考虑下n为奇数的例子。
```
0, 1, 2, 3, 4            1(8), 3(7), 5(6), 7(5), 0(4)
                 --->
5, 6, 7, 8               2(3), 4(2), 6(1), 8(0)
```

偶数情况: 0->1， 1->3， 5->0， 6->2...

奇数情况: 0->1， 1->3， 5->2， 6->4...

思路是要先列出想要达到的映射关系，然后再用公式实现。

> 思考下如果题目变为"nums[0] > nums[1] < nums[2] > nums[3]...."，

则映射关系的公式又是什么。如下图所示。

偶数情况:
```
0, 1, 2, 3, 4            0(9), 2(8), 4(7), 6(6), 8(5)
                 --->
5, 6, 7, 8, 9            1(4), 3(3), 5(2), 7(1), 9(0)
```

奇数情况:
```
0, 1, 2, 3, 4            0(8), 2(7), 4(6), 6(5), 8(4)
                 --->
5, 6, 7, 8               1(3), 3(2), 5(1), 7(0)
```

哈哈，公布答案啦，映射公式为(cur * 2) % ((n-1)|1)。

`(n-1)|1`表示如果是偶数的话则减1，奇数不变。

submit的结果为:
```
44 / 44 test cases passed.
Status: Accepted
Runtime: 192 ms
```
