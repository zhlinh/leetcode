首先需要先理解Maximun Number，一开始我就理解错了，囧。。。

还以为是和最大的序列，其实是排序最大的序列，例如[9, 4, 1] > [8, 9, 4]。

先求一个序列中规定长度为i的最大序列，
方法为不断pop掉当前生成序列out的小于当前num的最后一位。

如[4, 9, 3, 2, 1, 8, 7, 6]如果i = 2，则drop的个数为8-2等于6，可以至多pop掉6个数。
因为再pop的话out的长度就小于2了。

pop的顺序为4, 1, 2, 3。然后out为[9, 8, 7, 6]只取前两位out[:2]即为[9, 8]。

这样就求出来一个序列中指定i大小的最大序列。

然后用同样的方法求另外一个序列规定长度为k-i的最大序列。

接着就是求两个序列合并起来的最大序列，用merge即可，每次都merge其中最大的。

所以就是在nums1求i长度的最大序列a，在nums2求k-i长度的b，
注意i <= len(nums) 且 k - i <= len(nums2)。
接着将a和b合并merge得到k长度的序列即可，

以i的取值作为循环，比较取其最大序列作为res。

时间复杂度为O((m+n)^3)。

submit的结果为:
```
102 / 102 test cases passed.
Status: Accepted
Runtime: 536 ms
```
