已经想到了从叶子节点入手，但却不知道从两边的叶子节点同时往中间推进。

一开始以为从所有的叶子节点往最后推，然后取最小层数的中值。
接着就发现出现了多条路径时就会懵圈了。

唉，还是太年轻啊。

本质上是双向BFS。一开始初始化邻接矩阵，然后把叶子节点全部加入到leaves中。

但需要等下一跳next的节点去除该连结成为叶子节点时才将其加入新的一层newLeaves中。

试想下某个节点如果有三条或多条路径时就是需要等其他方向的都到达该节点，
才会将该节点加入到新的一层叶子节点newLeaves中，才会继续往前推进。
因为要照顾某个较长的子树。

然后终止条件为n <= 2。n为2时说明leaves只剩下两个节点，
n为1时说明左右的BFS同时到达了某个节点。

整个思考的过程可以转换为如何从一个树的叶子节点用双向BFS寻找root节点的问题。

一开始邻接矩阵用了List[set(int)]的形式，
因为考虑没有重复edges，所以就用了List[List(int)]的形式，速度就快了很多。

submit的结果为:
```
66 / 66 test cases passed.
Status: Accepted
Runtime: 124 ms
```
