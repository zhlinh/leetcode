第一版用的是DFS，比较偏机器的思路。

人类估计不会这么想，哈哈，一般人会想到等出现错误然后再回溯的。

而这个DFS的思路是先算出需要移除的左括号的数目和右括号的数目。

注意不是单纯的计算两个的总数目然后相减之类。
因为判断是否配对要利用stack的思想，两个的总数目相等也会invalid。

**接着是要考虑每个单括号的状态只有两种，移除或不移除，而其他字母则一律不移除。**

所以主要的变量有rmLNum，rmRNum用来记录需要移除的括号数目，小于0则返回，控制不要移除过多了。

还有stack，用来判断是否valid，遇到左括号+1，遇到右括号-1。

pos记录位置，result和results就不用多说了，DFS常用的两个变量。
注意result有添加和不添加s[pos]两种状态。

另外results的类型是set，避免添加重复的结果。

submit的结果为:
```
125 / 125 test cases passed.
Status: Accepted
Runtime: 132 ms
```

第二版就比较人类思维，但真的是相当赞的实现。

也是DFS，但只有出现错误后再回溯，然后避免重复的删除。

用start_i记录出错的断点，即只有出现错误时然后纠正才进入下一层。

纠正所删除的点用start_j来记录，这个主要是存在于从顶部到最底部的一次路径中。
为了防止两层按不同的顺序删除不同的可删除点得到相同的结果。
注意可删除点必须是第一个与前一个不重复的元素。

整个结构也是相当赞。

当能运行完循环i即是没有错误的结果，因为没有错误会continue，否则会开辟下一层。
return表示回溯到上一层。

然后将序列倒序，然后用相同的方法来删除多余的’(’，这样代码就可以复用了。
用pair即[‘(’, ’)’]和pair即[‘)’, ’(’]来区分两次删除不同的符号。

只有pair为[‘)’, ’(’]才将最后结果加入到results中。

在整个过程中s是不断变化的。因为每个断点出现时都会删除一个元素。
相当于i(start_i)和j(start_j)都加了1，这样就自然表示新的开始点，而不用再加1。

可以看出来比第一版DFS区别在于第一版是每一个元素都会开辟新的一层，删或不删。
而这个是出现错误再删除不同位置纠错然后开辟新的一层。

而且这个不用set来避免重复，而是在纠错删除的时候就不删除重复的元素。
而删除多个元素的时候，用了start_j保证每次都往前检验来避免出现重复。

不得不说相当awesome。

```
还有一种解法是用BFS，即从最长的开始，然后判断是否valid。

然后如果否，则删除一个’(‘或’)’元素，如果是新的序列(用visited来保证)，则添加到queue中。

接着再判断是否valid，直到出现valid则不再进入下一层。即删除最少的元素。

即每一层都比上一层少一个元素。

但每一次都要检验s是否valid就不太喜欢这种解法。
```

submit的结果为:
```
125 / 125 test cases passed.
Status: Accepted
Runtime: 68 ms
```
