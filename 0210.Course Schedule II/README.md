只需要一个有效解即可。

那就BFS然后记录一条路径即可。需要一个indegree数组，记录邻节点的入度。

当入度为0时加入queue，这也就是修完了所有前序课程的意思。

然后这个也可以防止环的出现，因为如果有环则无法进入该环，即无法完成其所需的前序课程。

submit的结果为:
```
36 / 36 test cases passed.
Status: Accepted
Runtime: 72 ms
```

第二版用的递归的DFS，循环的DFS只需要把BFS中的queue改为stack即可。

这样就可以保证如果完成前序课程会一路学下去。而不是像BFS会在两条链路上摇摆。

一开始以为递归的无法保证路径是对的。因为总是先访问较长的序列。

后来发现在什么时候添加进res才是关键。

此处是在递归的dfs之后添加，即会从最后一个栈顶逐渐往前添加。

然后返回时取逆序。

这样就保证了肯定能完成其前序课程。

举个例子：
```
1 -> 2 -> 3 -> 4 -> 5
1 -> 7 -> 3
1 -> 9 -> 3

res = [5, 4, 3, 2, 7, 9, 1]
```

返回其逆序[1, 9, 7, 2, 3, 4, 5]

submit的结果为:
```
36 / 36 test cases passed.
Status: Accepted
Runtime: 84 ms
```
