其实就是在计算每一位为1时的可能个数，然后将其相加。

举例n = 1392。

m = 1 时，a = 1392， b = 0，就是在计算个位为1时的可能个数。

(a // 10)得到139，因为实际上分开的是3个部分，不含a的末尾本身。

然后(a // 10 + 1) * m为140，即(a // 10)可以为0-139，当a % 10若取值为1时。

以上为a % 10的实际值大于2的情况。

然后需要考虑a % 10的实际值为0和实际值为1的情况。

如果 a % 10 为0时，即如果n = 1390的情况，则 (a // 10）只可以为0-138。

如果 a % 10 为1时，即如果n = 1391的情况，则 (a // 10) 只可以为0-138，且需要加上(b+1)，因为1391后面只能从0跟到b为止。

所以 ((a + 8) // 10) * m + (a // 10 == 1) * (b + 1) 考虑了所有的情况()。

m = 10 时，即计算的是十位为1时的可能个数。

...

m = 1000时，计算的就是最后一位千位时的可能个数。

submit的结果为:
```
40 / 40 test cases passed.
Status: Accepted
Runtime: 44 ms
```
