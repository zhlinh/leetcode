很容易想到DP的方法，但dp[i]的赋值依据不是dp[i-1]。

而是之前的每一个比nums[i]小的nums[j]所对应的dp[j]。

dp[i] = max(dp[i], dp[j] + 1)，其中j由nums[j] < nums[i], j < i限定。

时间复杂度为O(n^2)。

submit的结果为:
```
22 / 22 test cases passed.
Status: Accepted
Runtime: 1628 ms
```

第二版应该不算DP，但却是O(nlong(n))的方法。

解释起来可能比较麻烦，但领会了就觉得很有意思。

首先解释一下[2, 3, 5, 4, 1, 7]的情况。

当形成[2, 3, 5]的递增子序列时，遇到了4该怎么办。

很明显应该用4来替换5，因为4比5小，替换后长度相等，且更容易形成更长的子序列。

1.这种情况就是大于倒数第二个元素小于最后一个元素时的替换情况，
  替换掉此时长度最长的子序列。

2.另外如果出现1小于2时，即小于第一个元素时，应该以1作为新的子序列，
  替换掉长度为1的子序列。

3.还有一种情况就是7大于4的时候，则以7来增大子序列的长度。
  新维护一个长度加一的子序列。

看起来需要维护多个不同长度的子序列，是不是就难以实现了。

其实只需要维护多个不同长度子序列的最后一个元素即可。

注意每个子序列的长度均不相同，因为如果有相同的，则属于情况1，会替换掉最后一个元素。

比如遍历[2, 3, 5, 4, 1, 7]的子序列的情况依次为:

```
2

2
2, 3

2
2, 3
2, 3, 5

2
2, 3
2, 3, 4

1
2, 3
2, 3, 4

1
2, 3
2, 3, 4
2, 3, 4, 7
```

其实你发现情况2的本质也是情况1，即不允许出现相同长度的子序列，
所以长度为1的最后一个元素即lists[0]就被替换成了更小的数。

所以就需要维护一个lists保存每个不同长度的子序列的最后一个元素即可。
lists的长度便为当前的最长子序列的长度。

另外O(log(n))的时间耗费在寻找恰好大于新出现的中值元素的后一个元素上，
因为要替换掉后一个元素。

所以分三种情况: nums[i] < lists[0], nums[i] > lists[-1]
以及其他情况(在中间插入，即替换掉中间某个长度的子序列的最后一个元素，二分法查找)。

submit的结果为:
```
22 / 22 test cases passed.
Status: Accepted
Runtime: 64 ms
```
