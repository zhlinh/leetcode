其实就是在计算每一位为1时的可能个数，然后将其相加。

举例n = 1392。

将其分为`a | b`，需要逐一计算a的末尾一位为1时的个数
(需要再细分为`a前缀(不含a的末位) | a的末位 | b`)。

m = 1 时，a = 1392， b = 0，就是在计算个位为1时的可能个数。

(a // 10)得到139，因为此时实际上将a分开了2个部分。
即a前缀(不含a的末位) | a的末位。

然后(a // 10 + 1) * m为140，即(a // 10)可以为0-139，当a % 10若取值为1时。

以上为a % 10的实际值大于2的情况。

然后需要考虑a % 10的实际值为0和实际值为1的情况。

如果 a % 10 为0时，即如果n = 1390，则 (a // 10）只可以为0-138。

如果 a % 10 为1时，即如果n = 1391，则 (a // 10) 只可以为0-138，
且需要加上(b+1)，因为1391后面只能从0跟到b为止，而不是加m。

所以 ((a + 8) // 10) * m + (a % 10 == 1) * (b + 1) 考虑了所有的情况()。

或者是 (a // 10) * m + (a % 10 == 1) * (b + 1) + (a % 10 > 1) * m，
这样可能更容易理解。

m = 10 时，即计算的是十位为1时的可能个数。

...

m = 1000时，计算的就是最后一位千位时的可能个数。

submit的结果为:
```
40 / 40 test cases passed.
Status: Accepted
Runtime: 44 ms
```
