主要问题是下一个状态的存储问题，因为要in-space。

因为board的值只有0和1，所以用第二位来存储下一状态，即00,01,10,11的形式。

board[i][j] & 1为当前状态。

最终的时候再循环来将board[i][j] >>= 1即可。

因为默认的下一状态为0(dead)，所以只需改变下一状态为1(live)的。

然后就是计算周围邻居的活的个数的问题，需要注意的是边界问题。
与边界比较取max和min。计算九宫格的live个数，然后再减去自身的状态。

时间复杂度为O(mn)。

submit的结果为:
```
22 / 22 test cases passed.
Status: Accepted
Runtime: 44 ms
```
