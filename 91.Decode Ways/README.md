第一版最先想到的就是DP，但DP只用于计算连续的1, 2序列。

试错了好多次。

需要考虑的情况：

先排除”0”, “00”, “30”

遇到“0”, count -= 2，因为最后一个1或2相当于没了，然后按边界考虑。

考虑已到达边界以及27, 28, 29的伪边界的情况，count -= 1。

submit的结果为:
```
259 / 259 test cases passed.
Status: Accepted
Runtime: 52 ms
```

第二版才是真正的DP，而且不用dp数组，只需要记录之前的两个值就可以了。

这是从前往后的，当然也可以从后往前。

思路都是一样的，从前往后的需要判断前一个值与当前值，当s[i]为‘0’时前一个dp值为0。

从后往前的需要判断当前值与后一个值，当s[i]为’0’时，当前dp值为0。

submit的结果为:
```
259 / 259 test cases passed.
Status: Accepted
Runtime: 48 ms
```
