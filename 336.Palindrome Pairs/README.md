表示只能想到将两两组合然后判断是否为回文，这样的复杂度为(O(k*n^2))。
k为word的长度，n为words的长度。

可以换一种思路，引入dic存储所有的words及其下标，
转而求某word若想构成回文所需要的字符串是否在dic中。

这样就是逐一切割word为左右两部分，

1. 若左边为回文，则判断右边的逆序是否在dic中且下标与当前word的下标i不相同，
如果符合则res加入[dic[right[::-1]], i]

2. 若右边为回文，则与左边的情况相似，只是res加入的是[i, dic[left[::-1]]]

还需要注意两点：

第一个是word的遍历条件应为j <= len(word)，为了让空字符串也能进入循环。

第二个则是判断右边为回文时需要加上len(right) > 0，为了避免重复添加。

如[“ab”, ”ab”]时，检验每一个ab时res只添加左边为回文的一种情况。这样就可以避免重复添加。

时间复杂度为(O(n*k^2))。即检验回文用了O(k)，遍历words和遍历word分别用来O(n)和O(k)。

成功用dic把原来第二层遍历用时O(n)转为了O(k)。

sumbmit的结果为:
```
134 / 134 test cases passed.
Status: Accepted
Runtime: 1160 ms
```
