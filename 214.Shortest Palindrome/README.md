这道题求得就是从下标0开始最长的回文子序列[关键]。

然后再在最全面补全后面的逆序列，这样构成了一个回文序列。

一开始就是按定义求的，妥妥的O(n^2)，妥妥的LTE。

然后看了别人的答案发现是用KMP求的，实在太聪明。

先构造序列s + “#” + rev_s。

在中间必须得加入”#”的原因是避免类似”aabba”，不加的话就变成”aabbaabbaa”。

这样会被认为本身就是一个回文序列，最终会返回”aabba”。

而答案是“abbaabba”。

举个例子”catacb”变为”catacb#bcatac”。

然后next数组的最后一位为4(下标值)，即最长的前缀和后缀共有元素个数为5(4+1)。

亦即原序列最长的回文序列的长度为5(4+1)。

剩下的就是补全的工作了。

只需在最前面补一个rev_s[0:n-(next[-1]+1)]”b“即可构成回文序列”bcatacb”

submit的结果为:
```
117 / 117 test cases passed.
Status: Accepted
Runtime: 96 ms
```
