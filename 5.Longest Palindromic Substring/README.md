1. 最先开始的时候以为只需要找到相邻两个相同的，然后再往两边扩大范围。

   即可找到最长的回文序列。时间复杂度为O(n^2)

   后来发现回文序列不只有\*aa\*的形式，还有\*bab\*的形式。

   然后很容易想到再找相隔一个字符相同的，然后再往两边扩大范围。

   通过了测试，但Runtime为1500ms，实在是太差劲了。

2. 接着换了种思路，直接比较substr和substr[::-1]是否相等以判断是否为回文序列。

   天真的我用maxLen从len(s)逐一往下递减，时间复杂度为O(n^2)，然后就悲剧了。

   测试结果为超过时间限制。Oh, no。比之前的思路还差劲。

3. 看了下别人的答案，改了一版，maxLen从1开始的。

   有个小技巧就是需要比较一次加入两个字符和加入一个字符的情况。

   分别对应回文序列的两种情况，哈哈，这个思路赞啊。

   当一次加入两个字符的情况为回文序列时，就跳过判断一次加入一个字符的情况。

   因为maxLen会比一次加入一个字符多1。

submit的结果为:
```
88 / 88 test cases passed.
Status: Accepted
Runtime: 104 ms
```
