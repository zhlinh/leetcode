第一版用了DP的方法。

试过了二重循环然后再判断是否回文，这就O(n^3)，然后再dfs得出数目会TLE。

所以这次采用的dp是：

以当前为中心[奇数时中心，偶数时偏左边的一个]的回文字符串，

最后字符的dp至多是第一个字符之前的一个字符的dp数值加1，

即这个回文字符只需要再切一刀，当然还要与当前值比较取较小值。

分为奇数和偶数回文考虑。

简直太巧妙了。

时间复杂度为O(n^2)。

sumbmit的结果为:
```
28 / 28 test cases passed.
Status: Accepted
Runtime: 432 ms
```
