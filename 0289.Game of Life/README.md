主要问题是下一个状态的存储问题，因为要in-space。

因为board的值只有0和1，所以用倒数第二个比特来存储下一状态，即00,01,10,11的形式。

最后一个比特，即board[i][j] & 1为当前状态。

最终的时候再循环来将board[i][j] >>= 1即可。

因为默认的下一状态即倒数第二个比特为0(dead)，所以只需改变下一状态为1(live)的。

然后就是计算周围邻居的活的个数的问题，需要注意的是边界问题。

与边界比较取max(i-1, 0)、min(i+2, m)和max(j-1, 0)、min(j+2, m)。
计算九宫格的live个数，然后再减去自身的状态，便得到邻居的live个数。

时间复杂度为O(mn)。

submit的结果为:
```
22 / 22 test cases passed.
Status: Accepted
Runtime: 44 ms
```
