第一版是比较容易想到的思路，即将每个字母的下标列成数组。

先遍历一遍s，就可以得到一个各字母按下标的大小排列的二维数组letters[26][]。

然后按字典序逐一添加。添加的位置letters[i][0]必须要小于等于所有字母的最大位置letters[i][-1]的最小值。

出现等于是因为某个letters[i]只有一个下标时有可能是它自身。

这样才能保证可以依序添加完所有字母，添加的字母将该字母的下标数组置为空数组或None。
并记录添加的下标。

接下来就是从letters[i]中比所添加的下标要小的值，以保证依序添加。

如果认为O(26 * 26)的查找算是O(1)的话。

那么时间复杂度就是O(n)，耗费在删除所有字母的下标上。

submit的结果为:
```
286 / 286 test cases passed.
Status: Accepted
Runtime: 73 ms
```
