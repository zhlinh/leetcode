第一版用了一个stack。

如果高度是升序的，就不断将下标添加到stack中。

注意需要在最后再添加一个高度为0的元素，就不用再另外考虑最后一段了。

遇到了高度比栈顶的下标所代表高度还小的元素时，就会进入循环，
不断pop掉栈顶元素得出高度h，然后有i - stack[-1] - 1(前一个高度比i大位置)得出长度l。
当stack为空时，长度就为i。

注意必须pop然后由前一个stack[-1]得出长度l，而不是由当前stack[-1]。

因为有可能是[1, 4, 5, 3, 2]。

当i=3到元素3的位置后，stack中剩下的是[1]。

当i=4到元素2的位置后，stack中剩下的是[1, 3]。
计算长度l应该是(4 - 0 - 1)，而不是(4 - 3)。

submit的结果为:
```
94 / 94 test cases passed.
Status: Accepted
Runtime: 80 ms
```
